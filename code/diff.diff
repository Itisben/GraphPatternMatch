diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/alt.cpp b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/alt.cpp
index 5a2a130..2ec7b86 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/alt.cpp
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/alt.cpp
@@ -1,10 +1,33 @@
 #include "alt.h"
 
-Alt::Alt(Graph *g, Group *group, Query *query){
+AltGroup::AltGroup(Graph *g){
+	g_ = g;
+	label_num_ = g->label_num() + 1; //for 0
+	items_.reserve(label_num_);
+
+	list<int> item;
+	items_.insert(items_.begin(), label_num_, item);
+
+	//init all the group
+	for (auto it = g_->vertices()->begin(); it != g_->vertices()->end(); it++){
+		if (it->label < 0){
+			cout << "Group init error" << endl;
+			continue;
+		}
+		if (it->label >= (int)items_.size()){
+			cout << "label_num " << label_num_ << endl;
+			cout << "insert vertex  " << it->index << " to label " << it->label << endl;
+		}
+		items_[it->label].push_back(it->index);
+	}
+}
+
+Alt::Alt(Graph *g, AltGroup *group, Query *query, int landmark_num){
 	g_ = g;
 	group_ = group;
 	query_ = query;
-	deleta_ = query->delta();
+	delta_ = query->delta();
+	landmark_num_ = landmark_num;
 
 	/*for vertex*/
 	vector<int> dist;
@@ -14,38 +37,68 @@ Alt::Alt(Graph *g, Group *group, Query *query){
 	/*for group*/
 	dist.clear();
 	dist.insert(dist.begin(), landmark_num_, kInfinity);
-	l_group_min_dists_.insert(l_group_min_dists_.begin(), group_->label_num(), dist);
-	l_group_max_dists_.insert(l_group_max_dists_.begin(), group_->label_num(), dist);
+	//l_group_min_dists_.insert(l_group_min_dists_.begin(), group_->label_num(), dist);
+	//l_group_max_dists_.insert(l_group_max_dists_.begin(), group_->label_num(), dist);
 }
 
-ERR Alt::ChooseLandmark(int num){
+ERR Alt::ChooseLandmark(int num, int strategy){
 	landmark_num_ = num;
 	int s = rand() % g_->max_vertex_num();
-	int farest_vertex;
 	set<int> landmarks_set;
+	vector<int> rand_range;
+	
+	for (int i = 0; i < g_->max_vertex_num(); i++){
+		rand_range.push_back(i);
+	}
+	MyRandRange(&rand_range, g_->max_vertex_num());
 
-	auto fun = [](int s, int dir, Vertex *u, int argc, void **argv){
-		int *farest_vertex = (int*)argv[0];
-		*farest_vertex = u->index;
-		return 0;
-	};
+	if (RANDOM_SELECT == strategy){
+		landmarks_.clear();
+		landmarks_.insert(landmarks_.begin(), rand_range.begin(), rand_range.begin() + num);
+	}
+	else if (FASTEST_SELECT == strategy){
 
-	for (int i = 0; (int)landmarks_set.size() < num; i++){
-		int argc = 1;
-		void *argv[] = { &farest_vertex };
-		g_->Dijkstra(s, 0, fun, argc, argv);
-		
-		if (landmarks_set.find(farest_vertex) != landmarks_set.end()){
-			s = rand() % g_->max_vertex_num();
+		auto fun = [](int s, int dir, Vertex *u, int argc, void **argv){
+			int *farest_vertex = (int*)argv[0];
+			int *max_dist = (int*)argv[1];
+			if (u->dist == kInfinity)
+				return -1;
+			if (u->dist > *max_dist){
+				*farest_vertex = u->index;
+				*max_dist = u->dist;
+			}
+			return 0;
+		};
+
+		s = rand_range[0];
+		int i = 1;
+		while (true){
+			int argc = 2;
+			int farest_vertex = -1;
+			int max_dist = 0;
+			void *argv[] = { &farest_vertex, &max_dist };
+
+			g_->Dijkstra(s, 0, fun, argc, argv);
+			cout << "rand vertex: " << s << " fastest vertex: " << farest_vertex << " maxdist: " << max_dist << endl;
+			
+			if (landmarks_set.find(farest_vertex) == landmarks_set.end()){
+				landmarks_set.insert(farest_vertex);
+				s = farest_vertex;
+			}
+			else{
+				s = rand_range[i++];
+			}
+			cout << "rand " << i << "   size " << landmarks_set.size() << endl;
+			if (num <= (int)landmarks_set.size())
+				break;
 		}
-		else{
-			landmarks_set.insert(farest_vertex);
-			s = farest_vertex;
-		}	
+			
+		
+	
+		landmarks_.clear();
+		landmarks_.insert(landmarks_.begin(), landmarks_set.begin(), landmarks_set.end());
 	}
-
-	landmarks_.clear();
-	landmarks_.insert(landmarks_.begin(), landmarks_set.begin(), landmarks_set.end());
+	
 	return 0;
 }
 
@@ -66,44 +119,143 @@ ERR Alt::ConstructLandmarkDist(){
 	return 0;
 }
 
-ERR Alt::UpdateLandmarkGroupDist(){
+ERR Alt::WriteLandmark(const char *filename, const char *delim){
+	int error;
+	FILE *fp;
+	string strbuf;
+	char buf[32];
+
+	error = fopen_s(&fp, filename, "w");
+	if (0 != error)
+	{
+		ERR_COUT(<< "open file failed! " << strerror(error) << endl;);
+		return -1;
+	}
+
+	for (int i = 0; i < (int)l_vertex_dists_.size(); i++)
+	{	
+		int vertex = i;
+		strbuf = _itoa(i, buf, 10); //vertex ID
+		auto dists = &l_vertex_dists_[i];
+		for (auto it = dists->begin(); it != dists->end(); it++)
+		{
+			// vertexID, landm value 1, 2 3, 
+			strbuf += delim;
+			int dist;
+			if (*it == kInfinity)
+				dist = -1;
+			else
+				dist = *it;
+			strbuf += _itoa(dist, buf, 10);
+		}
+		strbuf += "\n";
+		fwrite(strbuf.data(), sizeof(char), strbuf.length(), fp);
+	}
+
+	fclose(fp);
+	return 0;
+
+}
+
+ERR Alt::ReadLandmark(const char *filename, const char* delim){
+	int error;
+	FILE *fp;
+	int kBufSize = 256;
+	char *strbuf = new char[kBufSize];
+	char *p;
+
+	error = fopen_s(&fp, filename, "r");
+	if (0 != error)
+	{
+		ERR_COUT(<< "open file failed! " << strerror(error) << endl;);
+		return -1;
+	}
+
+	while (fgets(strbuf, kBufSize, fp) != NULL)
+	{
+		if (2 >= strlen(strbuf))
+			continue;
+		if (strbuf[0] == IGNORE_CUR_LINE)
+			continue;
+		if (strbuf[0] == IGNORE_BELOW_LINE)
+			break;
+
+		p = strtok(strbuf, delim); /*change the strbuf pointer.*/
+		if (NULL == p)
+			continue;
+		int vertex = atoi(p);
+		for (int i = 0; (p = strtok(NULL, delim)) != NULL; i++){
+			int value = atoi(p);
+			if (-1 == value)
+				value = kInfinity;
+			l_vertex_dists_[vertex][i] = value;
+		}
+	}
+
+	fclose(fp);
+	delete[](strbuf);
+	return 0;
+}
+
+#if 0
+ERR Alt::UpdateLandmarkGroupDist(bool is_in_query){
 	int max, min;
-	for (int label = 0; label < group_->label_num(); label++){
-		for (int landmark_index = 0; landmark_index < landmark_num(); landmark_index++){
-			l_group_min_dists_[label][landmark_index] = kInfinity;
-			l_group_max_dists_[label][landmark_index] = kInfinity;
-
-			max = 0;
-			min = kInfinity;
-			auto item = group_->items(label);
-			if (false == item->empty()){
-				for (auto it = item->begin(); it != item->end(); it++){
-					int value = l_vertex_dists_[*it][landmark_index];
-					if (value > max)
-						max = value;
-					if (value < min)
-						min = value;
+	if (is_in_query == false){
+		for (int label = 0; label < group_->label_num(); label++){
+			for (int landmark_index = 0; landmark_index < landmark_num(); landmark_index++){
+				l_group_min_dists_[label][landmark_index] = kInfinity;
+				l_group_max_dists_[label][landmark_index] = kInfinity;
+
+				max = 0;
+				min = kInfinity;
+				auto item = group_->items(label);
+				if (false == item->empty()){
+					for (auto it = item->begin(); it != item->end(); it++){
+						int value = l_vertex_dists_[*it][landmark_index];
+						if (value > max)
+							max = value;
+						if (value < min)
+							min = value;
+					}
+					l_group_min_dists_[label][landmark_index] = min;
+					l_group_max_dists_[label][landmark_index] = max;
+				}
+			}
+		}
+	}
+	else{
+		for (auto it = query_->label_set()->begin(); it != query_->label_set()->end(); it++){
+			int label = *it;
+			for (int landmark_index = 0; landmark_index < landmark_num(); landmark_index++){
+				l_group_min_dists_[label][landmark_index] = kInfinity;
+				l_group_max_dists_[label][landmark_index] = kInfinity;
+
+				max = 0;
+				min = kInfinity;
+				auto item = group_->items(label);
+				if (false == item->empty()){
+					for (auto it = item->begin(); it != item->end(); it++){
+						int value = l_vertex_dists_[*it][landmark_index];
+						if (value > max)
+							max = value;
+						if (value < min)
+							min = value;
+					}
+					l_group_min_dists_[label][landmark_index] = min;
+					l_group_max_dists_[label][landmark_index] = max;
 				}
-				l_group_min_dists_[label][landmark_index] = min;
-				l_group_max_dists_[label][landmark_index] = max;
 			}
 		}
 	}
 	return 0;
 }
+#endif
 
-int Alt::TriangleDist(int v1, int v2, bool is_v2_group){
+int Alt::EstimatDist(int u2, int u1){
 	int value = 0, new_value = 0;
 
-	for (int i = 0; i < landmark_num(); i++){
-		if (false == is_v2_group){
-			new_value = abs(l_vertex_dists_[v1][i] - l_vertex_dists_[v2][i]);
-		}
-		else{
-			int value1 = abs(l_vertex_dists_[v1][i] - l_group_min_dists_[v2][i]);
-			int value2 = abs(l_vertex_dists_[v1][i] - l_group_max_dists_[v2][i]);
-			new_value = min(value1, value2);
-		}
+	for (int i = 0; i < landmark_num_; i++){
+		new_value = abs(l_vertex_dists_[u1][i] - l_vertex_dists_[u2][i]);
 		if (new_value > value)
 			value = new_value;
 	}
@@ -111,10 +263,59 @@ int Alt::TriangleDist(int v1, int v2, bool is_v2_group){
 	return value;
 }
 
+int Alt::EstimatDistToGroup(int u, vector<vector<int>> *area_dists){
+	int value = 0, new_value = 0;
+	
+
+	for (int i = 0; i < landmark_num_; i++){
+		new_value = BinarySearch(l_vertex_dists_[u][i], &area_dists->at(i));
+		if (new_value > value)
+			value = new_value;
+	}
+
+	return value;
+
+}
+
+int Alt::BinarySearch(int d, vector<int> *area){
+	int begin = 0, end = area->size() - 1;
+	int mid;
+
+	int value2 = *area->rbegin();
+	int value1 = *area->begin();
+	if (d >= value2)
+		return abs(d - value2);
+	if (d <= value1)
+		return abs(d - value1);
+
+	while (begin < end){
+		mid = (begin + end) / 2;
+		
+		if (d == area->at(mid)){
+			return 0;
+		}
+		else if (d < area->at(mid)){
+			end = mid - 1;
+		}
+		else{
+			begin = mid+1;
+		}
+	}
+	int value = area->at(begin);
+	if (d > value){
+		return min(abs(value - d), abs(area->at(begin + 1) - d));
+	}
+	else{
+		return min(abs(value - d), abs(area->at(begin - 1) - d));
+	}
+}
+
 int Alt::FirstPrune(){
-	GroupItems *group_items[2];
+	list<int> *group_items[2];
 	int total = 0;
-
+	bool flag;
+BEGIN:
+	flag = false;
 	/*build support by previous buckets.*/
 	for (auto it = query_->label_pairs()->begin(); it != query_->label_pairs()->end(); it++){
 		auto label_pair = *it;
@@ -123,25 +324,143 @@ int Alt::FirstPrune(){
 		group_items[1] = group_->items(label[1]);
 
 		FOR_EACH_DIRECTION;
+#if 0
+		vector<vector<int>> area_dists; //landmark, dist
+		vector<int> temp;
+		area_dists.insert(area_dists.begin(), landmark_num_, temp);
+		for (int i = 0; i < landmark_num_; i++){
+			area_dists[i].reserve(group_items[OPP(dir)]->size());
+			for (auto it = group_items[OPP(dir)]->begin(); it != group_items[OPP(dir)]->end(); it++){
+				int vertex = *it;
+				area_dists[i].push_back(l_vertex_dists_[vertex][i]);
+			}
+			sort(area_dists[i].begin(), area_dists[i].end());
+		}
+
 		for (auto it = group_items[(dir)]->begin(); it != group_items[(dir)]->end();){
 			int v = *it;
-			if (TriangleDist(v, label[OPP(dir)], /*is group*/true) > deleta_){
+			int e_dist = EstimatDistToGroup(v, &area_dists);
+			//cout << v << " to label " << label[OPP(dir)] << " dist "<< e_dist << endl;
+			if (e_dist > delta_){
+				group_items[(dir)]->erase(it++);
+				total++;
+				flag = true;
+			}
+			else{
+				it++;
+			}
+		}
+#else
+		for (auto it = group_items[(dir)]->begin(); it != group_items[(dir)]->end();){
+			int u1 = *it;
+			bool has = false;
+			for (auto it2 = group_items[OPP(dir)]->begin(); it2 != group_items[OPP(dir)]->end(); it2++){
+				int u2 = *it2;
+				//cout << v << " to label " << label[OPP(dir)] << " dist "<< e_dist << endl;
+				int e_dist = EstimatDist(u1, u2);
+				if (e_dist <= delta_){
+					has = true;
+					break;
+				}		
+			}
+
+			if (false == has){
+				group_items[(dir)]->erase(it++);
+				total++;
+				flag = true;
+			}
+			else
+			{
+				it++;
+			}
+		}
+#endif
+		END_FOR_EACH_DIRCTION;
+	}
+
+	if (true == flag)
+		goto BEGIN;
+	return total;
+}
+int Alt::EmbeddingPrune(Embedding *embedding){
+	list<int> *group_items[2];
+	int total = 0;
+	bool flag;
+	bool has_one;
+BEGIN:
+	flag = false;
+	/*build support by previous buckets.*/
+	for (auto it = query_->label_pairs()->begin(); it != query_->label_pairs()->end(); it++){
+		auto label_pair = *it;
+		int label[2] = { label_pair.first, label_pair.second };
+		group_items[0] = group_->items(label[0]);
+		group_items[1] = group_->items(label[1]);
+
+		FOR_EACH_DIRECTION;
+		for (auto it = group_items[(dir)]->begin(); it != group_items[(dir)]->end(); it++){
+			int u1 = *it;
+			has_one = false;
+			for (auto it2 = group_items[OPP(dir)]->begin(); it2 != group_items[OPP(dir)]->end(); it2++){
+				int u2 = *it2;
+				if (embedding->CalculateL(u1, u2) <= delta_){
+					has_one = true;
+				}
+				
+			}
+			if (has_one == false){
 				group_items[(dir)]->erase(it++);
 				total++;
 			}
 			else{
 				it++;
 			}
+				
 		}
 		END_FOR_EACH_DIRCTION;
 	}
 
+	//if (true == flag)
+		//goto BEGIN;
 	return total;
 }
+#if 0
+ERR Alt::AStar(int s, int label){
+	auto dikstrafun = [](int s, int dir, Vertex *u, int argc, void **argv){
+		int *delta = (int *)argv[0];
+		if (u->dist > *delta){
+			return -1;
+		}
+		return 0;
+	};
 
-ERR Alt::AStar(){
-	
+	auto heuristicfun = [](int dir, Vertex *u, int argc, void **argv){
+		int value = 0, new_value = 0;
+		LandmarkDists* l_vertex_dists_ = (LandmarkDists*)argv[0];
+		LandmarkDists* l_group_min_dists_ = (LandmarkDists*)argv[1];
+		LandmarkDists* l_group_max_dists_ = (LandmarkDists*)argv[2];
+		int landmark_num = *(int*)argv[3];
+		int label = *(int*)argv[4];
+
+		int v1 = u->index;
+		int v2 = label;
+		for (int i = 0; i < landmark_num; i++){
+			int value1 = abs((*l_vertex_dists_)[v1][i] - (*l_group_min_dists_)[v2][i]);
+			int value2 = abs((*l_vertex_dists_)[v1][i] - (*l_group_max_dists_)[v2][i]);
+			new_value = max(value1, value2); /*find the farest node in the cluster not the nearest one.*/
+			if (new_value > value)
+				value = new_value;
+		}
+		return value;
+	};
+
+	int argc = 1;
+	void *argv[] = { &delta_ };
+	int argc2 = 5;
+	void *argv2[] = { &l_vertex_dists_, &l_group_min_dists_, &l_group_max_dists_, &landmark_num_ , &label};
+	g_->AStar(s, 0, dikstrafun, argc, argv, heuristicfun, argc2, argv2);
+	return 0;
 }
+#endif
 int HeuristicFuntion(){
 	return 0;
 }
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/alt.h b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/alt.h
index 39c17e6..d966e8d 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/alt.h
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/alt.h
@@ -4,36 +4,65 @@
 #include "graph.h"
 #include "group.h"
 #include "query.h"
+#include "embedding.h"
 
 typedef vector<int> Landmarks;
 typedef vector<vector<int>> LandmarkDists;
+typedef vector<int> AltSupportCount;
+typedef vector<list<int>> AltSupport;
+enum LandmarkSelectStrategy{
+	START_SELECT = 0,
+	DEFINE_SELECT,
+	RANDOM_SELECT,
+	FASTEST_SELECT,
+};
+class AltGroup{
+private:
+	int label_num_;
+	Graph *g_;
+	vector<list<int>> items_;
+public:
+	AltGroup(Graph *g);
+	vector<list<int>> *items(){ return &items_; };
+	list<int> *items(int label){ return &items_[label]; }
+	int label_num(){ return label_num_; }
+};
+
 class Alt{
 private:
 	Graph *g_;
-	Group *group_;
+	AltGroup *group_;
 	Query *query_;
-	int deleta_;
+	int delta_;
 	int landmark_num_;
-
+public:
 	Landmarks landmarks_;
 	LandmarkDists l_vertex_dists_; //key:vertex, value landmarks value.
-	LandmarkDists l_group_min_dists_; //key:label, value landmarks.
-	LandmarkDists l_group_max_dists_;
+	//LandmarkDists l_group_min_dists_; //key:label, value landmarks.
+	//LandmarkDists l_group_max_dists_;
+	
+	AltSupportCount support_count_;
+	AltSupport support_;
 public:
-	Alt(Graph *g, Group *group, Query *query);
+	Alt(Graph *g, AltGroup *group, Query *query, int landmark_num);
 	
-	ERR ChooseLandmark(int num);
+	ERR ChooseLandmark(int num, int strategy);
 	ERR ConstructLandmarkDist();
-	ERR UpdateLandmarkGroupDist();
-	ERR AStar();
+	ERR WriteLandmark(const char *filename, const char *delim);
+	ERR ReadLandmark(const char *filename, const char* delim);
+
+	ERR UpdateLandmarkGroupDist(bool is_in_query = false);
+	ERR AStar(int s, int label);
 	int HeuristicFuntion();
 	ERR ArcConsistency();
-	int TriangleDist(int v1, int v2, bool is_v2_group = false);
+	int EstimatDist(int u1, int u2);
+	int EstimatDistToGroup(int u, vector<vector<int>> *area_dists);
+	int BinarySearch(int d, vector<int> *area);
 	int FirstPrune();
 
-	ERR WriteLandmarkDist();
-	ERR ReadLandmarkDist();
+	int EmbeddingPrune(Embedding *embedding);
 	int landmark_num(){ return landmark_num_; }
+	Landmarks* landmarks(){ return &landmarks_; }
 };
 
 #endif
\ No newline at end of file
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/arc-consistency.cpp b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/arc-consistency.cpp
index 8b741d3..62d880e 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/arc-consistency.cpp
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/arc-consistency.cpp
@@ -1,5 +1,7 @@
 #include "arc-consistency.h"
 #include <Windows.h>
+#include "main.h"
+
 ArcConsistency::ArcConsistency(Graph *g, Query *q, Group *group){
 	g_ = g;
 	q_ = q;
@@ -93,7 +95,7 @@ int ArcConsistency::TwohopArcPruning(Twohop *twohop){
 				int vertex = it2->first;
 				int dist = it2->second;
 
-				if (dist > delta_) 
+				if (dist > delta_)
 					continue;
 
 				if (arc_map.find(vertex) != arc_map.end()){
@@ -1263,10 +1265,10 @@ ERR EmbeddingAC::EmbeddingArcPruningByGroup(LabelPair label_pair){
 	return 0;
 }
 
-ERR EmbeddingAC::EmbeddingArcPruningByGroup2(LabelPair label_pair){
+int EmbeddingAC::EmbeddingArcPruningByGroup2(LabelPair label_pair){
 	DWORD start_time, end_time;
 	start_time = GetTickCount();
-
+	int total = 0;
 	Bucket temp_bucket;
 
 	int label[2] = { label_pair.first, label_pair.second };
@@ -1285,9 +1287,12 @@ ERR EmbeddingAC::EmbeddingArcPruningByGroup2(LabelPair label_pair){
 				support_sets_[0][u1].insert(u2);
 				support_sets_[1][u2].insert(u1);
 			}
+			else{
+				total++;
+			}
 		}
 	}
-	return 0;
+	return total; //unqualified
 }
 
 ERR EmbeddingAC::EmbeddingArcPruningByGroupUndirect(LabelPair label_pair){
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/arc-consistency.h b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/arc-consistency.h
index 21799e5..7b067cc 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/arc-consistency.h
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/arc-consistency.h
@@ -70,7 +70,7 @@ public:
 	ERR EmbeddingArcPruning();
 	ERR EmbeddingArcPruningByGroup(LabelPair label_pair);
 	/*new for directed graph*/
-	ERR EmbeddingArcPruningByGroup2(LabelPair label_pair);
+	int EmbeddingArcPruningByGroup2(LabelPair label_pair);
 	
 	int NeighborAreaPruningByGroup(LabelPair label_pair);
 	/*the L of embedding is < real d. so we need verify by dijkstra*/
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/edge-join.cpp b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/edge-join.cpp
index 1b6057d..3748802 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/edge-join.cpp
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/edge-join.cpp
@@ -1,5 +1,5 @@
 #include "edge-join.h"
-#include "main.h"
+//#include "main.h"
 
 EdgeJoin::EdgeJoin(Graph *g, Query *q, Group *group, Embedding* embedding,
 	Twohop *twohop, Cluster *cluster){
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/embedding.cpp b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/embedding.cpp
index 5ac2a39..295bad8 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/embedding.cpp
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/embedding.cpp
@@ -1,4 +1,5 @@
 #include "embedding.h"
+#include "main.h"
 /*
 *k is the dimention value. if k <= 0, set k to default value.
 */
@@ -121,8 +122,10 @@ int Embedding::CalculateL(int v0, int v1){
 		int L_new;
 
 		L_new = abs(rks_[v0][I] - rks_[v1][I]);
+		/*
 		if (L_new > kDelta) // for debug
 			return L_new;
+		*/
 		if (L_new > L)
 			L = L_new;
 	}
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/graph.cpp b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/graph.cpp
index a67afc0..a9db45e 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/graph.cpp
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/graph.cpp
@@ -413,6 +413,107 @@ int Graph::Dijkstra(int s, int direction, DijkstraFun dikstraFun, int argc, void
 	return heap_set.size();
 }
 
+/*
+*s : the index of the start vertex.
+*para_fun: the function that is for the dijkstra
+*/
+int Graph::AStar(int s, int direction, DijkstraFun dikstraFun, int argc, void **argv,
+	HeuristicFun heuristicFun, int argc2, void **argv2){
+	if (false == has_rgraph_ && direction == AIN)
+		return -1;
+
+	typedef struct{
+		int index;
+		int dist;
+	}HeapV;
+	Vertices *cur_vertices;
+	vector<HeapV> heap;
+	set<int> heap_set;
+	HeapV u;
+	HeapV heapV = { 0 };
+	Vertex *u_p, *v_p;
+
+	/*minimum heap*/
+	auto fun = [](HeapV u, HeapV v){ return u.dist > v.dist; };
+
+	//init heap
+	heap.reserve(max_vertex_num_);
+
+	//init
+	if (0 == direction)
+		cur_vertices = &vertices_;
+	else
+		cur_vertices = &r_vertices_;
+
+	if (false == cur_vertices->at(s).exist)
+		return -2;
+
+	for (auto it = cur_vertices->begin(); it != cur_vertices->end(); it++)
+	{
+		it->dist = kInfinity;
+		it->pai = -1;
+		it->color = kWhite;
+		if (false == it->exist){
+			it->color = kColorNotExist;
+		}
+	}
+	cur_vertices->at(s).dist = 0;
+
+	COUT(<< "the shortest path start from:" << s << endl;);
+	heapV = { s, 0 };
+	heap.push_back(heapV);
+	make_heap(heap.begin(), heap.end(), fun);
+
+	while (heap.size() > 0)
+	{
+		/*find the next nearest vertex by heap*/
+		bool has_next = false;
+		while (heap.size() > 0){
+			u = heap.front();
+			pop_heap(heap.begin(), heap.end(), fun);
+			heap.pop_back();
+			/*if this vertex has been visted, than get next.
+			*if this vertex has not been visted, get it and jump out.*/
+			if (heap_set.end() == heap_set.find(u.index)){
+				has_next = true;
+				u_p = &cur_vertices->at(u.index);
+				u_p->color = kBlack;
+				u_p->dist = u.dist;
+				heap_set.insert(u.index);
+				/*call back*/
+				if (-1 == dikstraFun(s, direction, u_p, argc, argv))
+					return -1;
+				break;
+			}
+		}
+
+		if (false == has_next)
+			break;
+
+		//here create the sp graph
+		u_p = &(*cur_vertices)[u.index];
+		for (auto it = u_p->edges.begin(); it != u_p->edges.end(); it++)
+		{
+			v_p = &(*cur_vertices)[it->vertex];
+			if (kWhite != v_p->color) //jump over not exist vertex.
+				continue;
+			//relax
+			/*heuristic funtion begin*/
+			int h = heuristicFun(direction, v_p, argc, argv); 
+			/*heuristic funtion end*/
+			int new_dist = u_p->dist + it->weight + h;
+			if (new_dist < v_p->dist)
+			{
+				v_p->dist = new_dist;
+				v_p->pai = u_p->index;
+				HeapV heapv = { v_p->index, new_dist };
+				heap.push_back(heapv);
+				push_heap(heap.begin(), heap.end(), fun);
+			}
+		}
+	}
+	return heap_set.size();
+}
 void Graph::TextDijkstra(){
 	for (auto it = vertices_.rbegin(); it != vertices_.rend(); it++){
 		Dijkstra(it->index, 0);
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/graph.h b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/graph.h
index c3125df..0839486 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/graph.h
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/graph.h
@@ -56,6 +56,7 @@ typedef list<set<int>> Sccs;
 //common callback function for dijkstra. if it return -1, than then the dijkstra end;  
 //data is the return value.
 typedef int(*DijkstraFun)(int s, int dir, Vertex *u, int argc, void **argv);
+typedef int(*HeuristicFun)(int dir, Vertex *u, int argc, void **argv);
 typedef vector<Vertex> Vertices;
 //typedef list<pair<int, int>> EdgePairs;
 typedef int(*DfsFun)(Vertex *u, int argc, void **argv);
@@ -81,7 +82,9 @@ public:
 	int ReadEdges(const char* filename, char* delim);
 	int ReadLabels(const char* filename, char* delim);
 	/*default direction is DOUT and the call back function is NULL */
-	int Dijkstra(int s, int direction=0, DijkstraFun dikstraFun=NULL, int argc=0, void **argv=NULL);
+	int AStar(int s, int direction=0, DijkstraFun dikstraFun=NULL, int argc=0, void **argv=NULL,
+		HeuristicFun heuristicFun = NULL, int argc2 = 0, void **argv2 = NULL);
+	int Dijkstra(int s, int direction = 0, DijkstraFun dikstraFun = NULL, int argc = 0, void **argv = NULL);
 	ERR Dfs(DfsFun dfsFun = NULL, int argc = 0, void **argv = NULL);
 	ERR Graph::DfsInTopoOrder(DfsFun dfsFun, int argc, void **argv);
 	vector<Vertex*>  *TopoSort();
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/main.cpp b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/main.cpp
index 9c9f1ae..d62ffbc 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/main.cpp
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/main.cpp
@@ -14,7 +14,8 @@
 #include "cluster.h"
 #include "edge-join.h"
 #include "alt.h"
-#include "main.h"
+#include "astar-ac.h"
+#include "twohopac.h"
 
 char *delime = ",";
 string g_path = PATH;
@@ -25,10 +26,14 @@ string g_twohop_path_2 = g_path + "twohop-no-pruning.csv";
 string g_embedding_path = g_path + "embedding.csv";
 string g_query_path = g_path + "query.csv";
 string g_cluster_path = g_path + "cluster.csv";
+string g_landmark_path = g_path + "landmark.csv";
+string g_pivot_path = g_path + "pivot.csv";
 string g_ac_twohop_path = g_path + "r-ac-twohop.csv";
 string g_edge_join_path = g_path + "r-edge-join.csv";
 string g_ac_emb_path = g_path + "r-ac_emd.csv";
 string g_ac_emb_no_verified_path = g_path + "r-ac_emd-no-verified.csv";
+string g_ac_landmark_path = g_path + "r-ac-landmark.csv";
+string g_twohopac_path = g_path + "r-twohopac.csv";
 
 void OffLineTwohop(){
 	cout << "OffLineTwohop" << endl;
@@ -126,7 +131,99 @@ void OffLineCluster(){
 	cout << endl;
 }
 
+void OfflineAlt(){
+	cout << endl;
+	cout << "Offline ALT" << endl;
+	DWORD start_time, end_time;
+
+	Graph *g = new Graph(kGraphVertexNum, /*directed*/false);
+	g->ReadEdges((char*)g_graph_path.data(), ",");
+	g->ReadLabels(g_label_path.data(), ",");
+	cout << "read graph complete... with label " << g->label_num() << endl;
+
+	AltGroup *group = new AltGroup(g);
+
+	Query *q = new Query(kQueryVertexNum, kDelta);
+	q->Start(g_query_path.data(), ",");
+	cout << "read q complete..." << endl;
+
+	cout << ">>>>>>ALT offline start..." << endl;
+
+	/*start timer*/
+	int landmark_num = 16;
+	start_time = GetTickCount();
+	Alt *alt = new Alt(g, group, q, landmark_num);
+	alt->ChooseLandmark(landmark_num, RANDOM_SELECT); //RANDOM_SELECT, FASTEST_SELECT
+	//alt->landmarks_.clear();
+	//alt->landmarks_.push_back(5961);
+	cout << "landmark: ";
+	for (auto it = alt->landmarks()->begin(); it != alt->landmarks()->end(); it++){
+		cout << *it << " ";
+	}
+	cout << endl;
+	alt->ConstructLandmarkDist();
+	end_time = GetTickCount();
+	/*end timer*/
+	alt->WriteLandmark(g_landmark_path.data(), ",");
+
+	cout << "alt offline time: " << end_time - start_time << " ms" << endl;
+
+	cout << endl;
+
+	delete(group);
+	delete(q);
+	delete(g);
+}
+
+void OfflineAstarAC(){
+	cout << endl;
+	cout << "Offline ALT" << endl;
+	DWORD start_time, end_time;
+
+	Graph *g = new Graph(kGraphVertexNum, /*directed*/true);
+	//Graph *g = new Graph(kGraphVertexNum, /*directed*/true);
+	g->ReadEdges((char*)g_graph_path.data(), ",");
+	g->ReadLabels(g_label_path.data(), ",");
+	cout << "read graph complete... with label " << g->label_num() << endl;
+
+	AACGroup *group = new AACGroup(g);
+
+	Query *q = new Query(kQueryVertexNum, kDelta);
+	q->Start(g_query_path.data(), ",");
+	cout << "read q complete..." << endl;
+
+	cout << ">>>>>>ALT offline start..." << endl;
+
+	/*start timer*/
+	start_time = GetTickCount();
+	AstarAC *aac = new AstarAC(g, group, q, kPivotNum);
+	aac->ChoosePivots(AAC_RANDOM_SELECT); //RANDOM_SELECT, FASTEST_SELECT
+	cout << "landmark: ";
+	for (auto it = aac->pivots()->begin(); it != aac->pivots()->end(); it++){
+		cout << *it << " ";
+	}
+	cout << endl;
+	aac->ConstructPivotsDist();
+	end_time = GetTickCount();
+	/*end timer*/
+	aac->WritePivotsDists(g_pivot_path.data(), ",");
+
+	cout << "alt offline time: " << end_time - start_time << " ms" << endl;
+
+	cout << endl;
+
+	delete(group);
+	delete(q);
+	delete(g);
+}
 void OnLineTwoHopAC(){
+	LARGE_INTEGER  large_interger;
+	double dff;
+	__int64  c1, c2;
+	QueryPerformanceFrequency(&large_interger);
+	dff = large_interger.QuadPart;
+
+
 	cout << "OnLineTwoHopAC"<< endl;
 	DWORD start_time, end_time;
 
@@ -145,14 +242,25 @@ void OnLineTwoHopAC(){
 
 	cout << "twohop AC start..." << endl;
 	start_time = GetTickCount();
+	
+	QueryPerformanceCounter(&large_interger);
+	c1 = large_interger.QuadPart;
+
 	/*start timer*/
 	Group *group = new Group(g);
 	ArcConsistency *ac = new ArcConsistency(g, q, group);
 	ac->TwohopArcPruning(twohop);
 	/*end timer*/
+	
+	QueryPerformanceCounter(&large_interger);
+	c2 = large_interger.QuadPart;
+
 	end_time = GetTickCount();
 	ac->write(g_ac_twohop_path.data(), delime);
 	cout << "twohop AC end." << end_time - start_time << " ms" << endl;
+
+	printf("twohop AC end %lf毫秒\n", (c2 - c1) * 1000 / dff);
+	
 	cout << endl;
 
 	delete(group);
@@ -285,35 +393,191 @@ void OnlineAlt(){
 	g->ReadLabels(g_label_path.data(), ",");
 	cout << "read graph complete... with label " << g->label_num() << endl;
 
-	Group *group = new Group(g);
+	AltGroup *group = new AltGroup(g);
 
 	Query *q = new Query(kQueryVertexNum, kDelta);
 	q->Start(g_query_path.data(), ",");
 	cout << "read q complete..." << endl;
 
-	cout << ">>>>>>ALT offline start..." << endl;
-	Alt *alt = new Alt(g, group, q);
-	alt->ChooseLandmark(16);
-	alt->ConstructLandmarkDist();
-	alt->UpdateLandmarkGroupDist();
+	
 
+	cout << ">>>>>>ALT offline start..." << endl;
+	Alt *alt = new Alt(g, group, q, 16);
+	//alt->ChooseLandmark(16, RANDOM_SELECT);
+	//alt->ConstructLandmarkDist();
+	alt->ReadLandmark(g_landmark_path.data(), ",");
 	start_time = GetTickCount();
 	/*start timer*/
 	int total = alt->FirstPrune();
-	cout << "total pruning : " << total << endl;
-	alt->UpdateLandmarkGroupDist();
 
 	/*end timer*/
 	end_time = GetTickCount();
+	cout << "total pruning : " << total << endl;
 	cout << "alt online time: " << end_time - start_time << " ms" << endl;
 	
+	Group *group2 = new Group(g);
+	Embedding *embedding = new Embedding(g, group2);
+	embedding->Read(g_embedding_path.data(), delime);
+	cout << "read embedding comlete..." << endl;
+
+	total = alt->EmbeddingPrune(embedding);
+	cout << "embedding total pruning : " << total << endl;
+
+	cout << endl;
+
+	delete(embedding);
+	delete(group);
+	delete(q);
+	delete(g);
+}
+
+void OnlineAstarAC(){
+	
+	LARGE_INTEGER  large_interger;
+	double dff;
+	__int64  c1, c2;
+	QueryPerformanceFrequency(&large_interger);
+	dff = large_interger.QuadPart;
+
+
+	cout << endl;
+	cout << "online ALT" << endl;
+	DWORD start_time, end_time;
+	int total;
+	pair<int, int> mypair;
+
+	Graph *g = new Graph(kGraphVertexNum, /*directed*/true);
+	g->ReadEdges((char*)g_graph_path.data(), ",");
+	g->ReadLabels(g_label_path.data(), ",");
+	cout << "read graph complete... with label " << g->label_num() << endl;
+
+	AACGroup *group = new AACGroup(g);
+
+	Query *q = new Query(kQueryVertexNum, kDelta);
+	q->Start(g_query_path.data(), ",");
+	cout << "read q complete..." << endl;
+
+
+
+	cout << ">>>>>>ALT online start..." << endl;
+	AstarAC *aac = new AstarAC(g, group, q, kPivotNum);
+	
+	aac->ReadPivotsDists(g_pivot_path.data(), ",");
+	start_time = GetTickCount();
+
+	QueryPerformanceCounter(&large_interger);
+	c1 = large_interger.QuadPart;
+	/*start timer*/
+	mypair = aac->FirstPrune();
+	/*end timer*/
+	QueryPerformanceCounter(&large_interger);
+	c2 = large_interger.QuadPart;
+	end_time = GetTickCount();
+
+	cout << "total pruning : " << mypair.second << " total: "<<mypair.first<<endl;
+	cout << "aac online time: " << end_time - start_time << " ms" << " "<<(c2-c1)*1000/dff << "ms"<< endl;
+
+	
+	Group *group2 = new Group(g);
+	AACGroup *group3 = new AACGroup(g);
+	AstarAC *aac2 = new AstarAC(g, group3, q, kPivotNum);
+	Embedding *embedding = new Embedding(g, group2);
+	embedding->Read(g_embedding_path.data(), delime);
+	cout << "read embedding comlete..." << endl;
+	
+	start_time = GetTickCount();
+	QueryPerformanceCounter(&large_interger);
+	c1 = large_interger.QuadPart;
+	/*start timer*/
+	mypair = aac2->EmbeddingPrune(embedding);
+	/*end timer*/
+	QueryPerformanceCounter(&large_interger);
+	c2 = large_interger.QuadPart;
+	end_time = GetTickCount();
+	cout << "embedding total pruning : " << mypair.second << " total: " << mypair.first << endl;
+	cout << "embedding online time: " << end_time - start_time << " ms" << " " << (c2 - c1) * 1000 / dff << " ms"<< endl;
 	cout << endl;
 
+	delete(group2);
+	delete(embedding);
 	delete(group);
 	delete(q);
 	delete(g);
 }
+#if 1
+void OnlineTwohopAcNew()
+{
+	LARGE_INTEGER  large_interger;
+	double dff;
+	__int64  c1, c2;
+	QueryPerformanceFrequency(&large_interger);
+	dff = large_interger.QuadPart;
+
+
+	cout << "OnLine New TwoHopAC" << endl;
+	DWORD start_time, end_time;
 
+	Graph *g = new Graph(kGraphVertexNum, true);
+	g->ReadEdges((char*)g_graph_path.data(), ",");
+	g->ReadLabels(g_label_path.data(), ",");
+	cout << "read graph complete... with label " << g->label_num() << endl;
+
+	Query *q = new Query(kQueryVertexNum, kDelta); //delta
+	q->Start(g_query_path.data(), ",");
+	cout << "read q complete..." << endl;
+
+
+	cout << "New twohop AC start..." << endl;
+	Group *group = new Group(g);
+	TwohopAc *tac = new TwohopAc(g, q, group);
+	tac->ReadLabeling(g_twohop_path.data(), ",");
+	tac->SortLabeling();
+
+	start_time = GetTickCount();
+
+	QueryPerformanceCounter(&large_interger);
+	c1 = large_interger.QuadPart;
+
+	/*start timer*/
+	
+	tac->AcJoin(HASH_JOIN);
+	/*end timer*/
+
+	QueryPerformanceCounter(&large_interger);
+	c2 = large_interger.QuadPart;
+
+	end_time = GetTickCount();
+	
+	cout << "twohop AC end." << end_time - start_time << " ms" << endl;
+
+	tac->WriteMatches(g_twohopac_path.data(), ",");
+	printf("twohop AC end %lf毫秒\n", (c2 - c1) * 1000 / dff);
+
+	cout << endl;
+
+	delete(group);
+	delete(q);
+	delete(g);
+	delete(tac);
+}
+#endif
+void TestTimer(){
+	LARGE_INTEGER  large_interger;
+	double dff;
+	__int64  c1, c2;
+	QueryPerformanceFrequency(&large_interger);
+	dff = large_interger.QuadPart;
+	QueryPerformanceCounter(&large_interger);
+	c1 = large_interger.QuadPart;
+	Sleep(800);
+	QueryPerformanceCounter(&large_interger);
+	c2 = large_interger.QuadPart;
+	printf("本机高精度计时器频率%lf\n", dff);
+	printf("第一次计时器值%I64d 第二次计时器值%I64d 计时器差%I64d\n", c1, c2, c2 - c1);
+	printf("计时%lf毫秒\n", (c2 - c1) * 1000 / dff);
+
+	printf("By MoreWindows\n");
+}
 int _tmain(int argc, _TCHAR* argv[]){
 	cout <<"********* " <<g_path.data() <<" **********" <<endl;
 	cout << "kGraphVertexNum " << kGraphVertexNum << endl;
@@ -333,22 +597,32 @@ int _tmain(int argc, _TCHAR* argv[]){
 	
 	OffLineCluster();
 #endif
-#if 0
-	//OnLineTwoHopAC();
+#if 1
+	OnLineTwoHopAC();
 	
+	OnlineTwohopAcNew();
+
 	g_ac_emb_path = g_path + "r-ac_emd-naive.csv";
-	OnLineEmbeddingAC(NAIVE_AC_JOIN, false/*neighbor area pruning*/); 
+	//OnLineEmbeddingAC(NAIVE_AC_JOIN, false/*neighbor area pruning*/); 
 	
 	g_ac_emb_path = g_path + "r-ac_emd.csv";
-	OnLineEmbeddingAC(HASH_AC_JOIN, true);
+	//OnLineEmbeddingAC(HASH_AC_JOIN, true);
 
-	OnLineEdgeJoin();
+	//OnLineEdgeJoin();
 #endif
 
-#if 1
-	OnlineAlt();
+#if 0
+	//OfflineAlt();
+	OfflineAstarAC();
 #endif
-	
+#if 0
+	//OnlineAlt();
+	OnlineAstarAC();
+#endif
+
+	TestTimer();
+	int test;
+	cin >> test;
 	return 0;
 }
 
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/main.h b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/main.h
index 3a13de8..c6f10c4 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/main.h
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/main.h
@@ -12,7 +12,8 @@
 
 
 
-#define TESTDATA 2
+#define TESTDATA 1
+const int kPivotNum = 20;
 #if TESTDATA == 0
 #define PATH  "..\\..\\new-test-example\\"
 const int kGraphVertexNum = 16;
@@ -34,7 +35,7 @@ const int KClusterMaxIteration = 10000;
 #define PATH "..\\..\\data-wiki-vote\\"
 const int kGraphVertexNum = 7116;
 const int kQueryVertexNum = 10;
-const int kDelta = 300;
+const int kDelta = 100;
 const int kClusterK = 100; //10;
 const int KClusterMaxIteration = 1000;
 #endif
@@ -68,12 +69,21 @@ const int KClusterMaxIteration = 1000;
 #define PATH "..\\..\\data-synthetic-graph\\";
 const int kGraphVertexNum = 100000;
 const int kQueryVertexNum = 10;
-const int kDelta = 300;
+const int kDelta = 500;
 const int kClusterK = 100;
 const int KClusterMaxIteration = 10000;
 const int kDirected = true;
-#endif
 
+#endif
+#if TESTDATA == 62
+#define PATH "..\\..\\data-synthetic-graph-2\\";
+const int kGraphVertexNum = 100000;
+const int kQueryVertexNum = 10;
+const int kDelta = 100;
+const int kClusterK = 100;
+const int KClusterMaxIteration = 10000;
+const int kDirected = true;
+#endif
 #if TESTDATA == 7
 #define PATH "..\\..\\data-patent-citation\\";
 const int kGraphVertexNum = 624051;
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/stdafx.h b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/stdafx.h
index 98744db..6efaec8 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/stdafx.h
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/stdafx.h
@@ -13,6 +13,7 @@
 #include <vector>
 #include <array>
 #include <map>
+#include <hash_map>
 #include <set>
 #include <stack>
 #include <queue>
@@ -26,7 +27,7 @@
 #include <unordered_set>
 
 using namespace std;
-#include "main.h"
+
 
 typedef int ERR;
 const int kInfinity = 10000000;
diff --git a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/twohop.cpp b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/twohop.cpp
index 1c34f49..b097be2 100644
--- a/GraphPatternMaching-2/GraphPatternMatch-New-1/code/twohop.cpp
+++ b/GraphPatternMaching-2/GraphPatternMatch-New-1/code/twohop.cpp
@@ -1,5 +1,5 @@
 #include "twohop.h"
-
+#include "main.h"
 Twohop::Twohop(Graph *g){
 	TwohopCluster c = {0};
 
diff --git a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/main.cpp b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/main.cpp
index 0b74ef1..0aa3180 100644
--- a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/main.cpp
+++ b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/main.cpp
@@ -23,11 +23,7 @@ string g_twohop_path_2 = g_path + "twohop-no-pruning.csv";
 string g_embedding_path = g_path + "embedding.csv";
 string g_query_path = g_path + "query.csv";
 string g_cluster_path = g_path + "cluster.csv";
-string g_ac_twohop_path = g_path + "r-ac-twohop.csv";
 string g_edge_join_path = g_path + "r-edge-join.csv";
-string g_ac_emb_path = g_path + "r-ac_emd.csv";
-string g_ac_emb_no_verified_path = g_path + "r-ac_emd-no-verified.csv";
-string g_ac_landmark_path = g_path + "r-ac-landmark.csv";
 string g_twohopac_path = g_path + "r-twohopac.csv";
 
 void OffLineTwohop(){
@@ -45,7 +41,7 @@ void OffLineTwohop(){
 
 	Twohop *twohop = new Twohop(g);
 	twohop->set_debug(1);
-#if 1 //paper's method 
+#if 0 //paper's method 
 	twohop->Start(false, 5);
 #else //simpler method
 	VertexSet v_set;
@@ -126,59 +122,6 @@ void OffLineCluster(){
 	cout << endl;
 }
 
-void OnLineTwoHopAC(){
-	LARGE_INTEGER  large_interger;
-	double dff;
-	__int64  c1, c2;
-	QueryPerformanceFrequency(&large_interger);
-	dff = large_interger.QuadPart;
-
-
-	cout << "OnLineTwoHopAC"<< endl;
-	DWORD start_time, end_time;
-
-	Graph *g = new Graph(kGraphVertexNum, true);
-	g->ReadEdges((char*)g_graph_path.data(), ",");
-	g->ReadLabels(g_label_path.data(), ",");
-	cout << "read graph complete... with label " << g->label_num() << endl;
-
-	Query *q = new Query(kQueryVertexNum, kDelta); //delta
-	q->Start(g_query_path.data(), ",");
-	cout << "read q complete..." << endl;
-
-	Twohop *twohop = new Twohop(g);
-	twohop->ReadCluster(g_twohop_path.data(), delime);
-	cout << "read twohopcluster complete..." << endl;
-
-	cout << "twohop AC start..." << endl;
-	start_time = GetTickCount();
-	
-	QueryPerformanceCounter(&large_interger);
-	c1 = large_interger.QuadPart;
-
-	/*start timer*/
-	Group *group = new Group(g);
-	//ArcConsistency *ac = new ArcConsistency(g, q, group);
-	//ac->TwohopArcPruning(twohop);
-	/*end timer*/
-	
-	QueryPerformanceCounter(&large_interger);
-	c2 = large_interger.QuadPart;
-
-	end_time = GetTickCount();
-	//ac->write(g_ac_twohop_path.data(), delime);
-	cout << "twohop AC end." << end_time - start_time << " ms" << endl;
-
-	printf("twohop AC end %lf毫秒\n", (c2 - c1) * 1000 / dff);
-	
-	cout << endl;
-
-	delete(group);
-	delete(q);
-	delete(g);
-	delete(twohop);
-}
-
 void OnLineEdgeJoin(){
 	cout << "OnLineEdgeJoin" << endl;
 	DWORD start_time, end_time;
@@ -244,7 +187,6 @@ void OnLineEdgeJoin(){
 
 }
 
-#if 1
 void OnlineTwohopAcNew()
 {
 	LARGE_INTEGER  large_interger;
@@ -271,7 +213,7 @@ void OnlineTwohopAcNew()
 	Group *group = new Group(g);
 	TwohopAc *tac = new TwohopAc(g, q, group);
 	tac->ReadLabeling(g_twohop_path.data(), ",");
-	tac->SortLabeling();
+	//tac->SortLabeling(); 
 
 	start_time = GetTickCount();
 
@@ -280,18 +222,15 @@ void OnlineTwohopAcNew()
 
 	/*start timer*/
 	
-	tac->AcJoin(HASH_JOIN);
+	tac->Sjoin(HASH_JOIN);
 	/*end timer*/
 
 	QueryPerformanceCounter(&large_interger);
 	c2 = large_interger.QuadPart;
-
-	end_time = GetTickCount();
-	
-	cout << "twohop AC end." << end_time - start_time << " ms" << endl;
+	printf("twohop AC end %lf ms \n", (c2 - c1) * 1000 / dff);
 
 	tac->WriteMatches(g_twohopac_path.data(), ",");
-	printf("twohop AC end %lf毫秒\n", (c2 - c1) * 1000 / dff);
+	printf("twohop AC write matces end %lf ms \n", (c2 - c1) * 1000 / dff);
 
 	cout << endl;
 
@@ -300,7 +239,7 @@ void OnlineTwohopAcNew()
 	delete(g);
 	delete(tac);
 }
-#endif
+
 void TestTimer(){
 	LARGE_INTEGER  large_interger;
 	double dff;
@@ -329,29 +268,20 @@ int _tmain(int argc, _TCHAR* argv[]){
 
 	/*init rand seed*/
 	srand((unsigned int)time(NULL));
-#if 1
+#if 0
 	OffLineTwohop();
 
 	OffLineEmbedding();
 	
 	OffLineCluster();
 #endif
-#if 0
-	OnLineTwoHopAC();
-	
+#if 1
 	OnlineTwohopAcNew();
 
-	g_ac_emb_path = g_path + "r-ac_emd-naive.csv";
-	//OnLineEmbeddingAC(NAIVE_AC_JOIN, false/*neighbor area pruning*/); 
-	
-	g_ac_emb_path = g_path + "r-ac_emd.csv";
-	//OnLineEmbeddingAC(HASH_AC_JOIN, true);
-
-	//OnLineEdgeJoin();
+	OnLineEdgeJoin();
 #endif
 
-
-	TestTimer();
+	cout << "end!" << endl;
 	int test;
 	cin >> test;
 	return 0;
diff --git a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/main.h b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/main.h
index 6ad9cd0..3df3931 100644
--- a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/main.h
+++ b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/main.h
@@ -26,9 +26,14 @@ const int KClusterMaxIteration = 1000;
 #define PATH "..\\dataset\\data-yeast\\"
 const int kGraphVertexNum = 2362;
 const int kQueryVertexNum = 10;
-const int kDelta = 3;
+const int kDelta = 4;
 const int kClusterK = 40;
-const int KClusterMaxIteration = 10000;
+const int KClusterMaxIteration = 1000;
+//for saving the memory
+//label 0 - 12
+const int kStartLable = 0;
+const int kEndLabel = 12;
+const int kMaxDelta = 0xfffffff;
 #endif
 #if TESTDATA == 2
 //string g_path = "..\\..\\new-test-wiki-vote\\";
@@ -40,7 +45,7 @@ const int kClusterK = 100; //10;
 const int KClusterMaxIteration = 1000;
 #endif
 #if TESTDATA == 3
-#define PATH "..\\..\\new-test-citeseer\\";
+#define PATH "..\\..\\data-citeseer\\";
 const int kGraphVertexNum = 384413;
 const int kQueryVertexNum = 5;
 const int kDelta = 50;
@@ -99,6 +104,5 @@ enum{
 	NAIVE_AC_JOIN = 1,
 	HASH_AC_JOIN,
 };
-const int kStartLable = 0;
-const int kEndLabel = 9;
+
 #endif
\ No newline at end of file
diff --git a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohop.cpp b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohop.cpp
index b097be2..8bc9fd0 100644
--- a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohop.cpp
+++ b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohop.cpp
@@ -391,6 +391,8 @@ int Twohop::WriteCluster(const char *filename, const char *delim){
 	for (auto it = clusters_.begin(); it != clusters_.end(); it++)
 	{
 		FOR_EACH_DIRECTION;	
+		//sort first
+		it->items[dir];
 		for (auto it2 = it->items[dir].begin(); it2 != it->items[dir].end(); it2++)
 		{
 			// center, dir, index, weight
@@ -402,6 +404,11 @@ int Twohop::WriteCluster(const char *filename, const char *delim){
 			strbuf += delim;
 			strbuf += _itoa(it2->second, buf, 10); //weight
 			strbuf += "\n";
+
+			//here for pruning save the memory.
+			if (it2->second > kMaxDelta)
+				continue;
+
 			fwrite(strbuf.data(), sizeof(char), strbuf.length(), fp);
 		}
 		
diff --git a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohopac.cpp b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohopac.cpp
index a061571..1c5282e 100644
--- a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohopac.cpp
+++ b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohopac.cpp
@@ -1,4 +1,5 @@
 #include "twohopac.h"
+#include "main.h"
 TwohopAc::TwohopAc(Graph *g, Query *q, Group *group){
 	g_ = g;
 	q_ = q;
@@ -14,7 +15,9 @@ TwohopAc::TwohopAc(Graph *g, Query *q, Group *group){
 	counts_[dir].insert(counts_[dir].begin(), g_->max_vertex_num(), c);
 	END_FOR_EACH_DIRCTION;
 }
+TwohopAc::~TwohopAc(){
 
+}
 int TwohopAc::ReadLabeling(const char *filename, const char *delim){
 	int error;
 	FILE *fp;
@@ -34,6 +37,11 @@ int TwohopAc::ReadLabeling(const char *filename, const char *delim){
 	{
 		if (4 > strlen(strbuf)) // jump the last line
 			continue;
+		
+		if ('*' == strbuf[0])
+			break;
+		else if ('#' == strbuf[0])
+			continue;
 
 		p = strtok(strbuf, delim);
 		if (NULL == p)
@@ -52,6 +60,10 @@ int TwohopAc::ReadLabeling(const char *filename, const char *delim){
 
 		int dir = value[1];
 		int vertex = value[0];
+
+		if (value[3] > kDelta)
+			continue; //pruning method
+
 		labelings_[dir][vertex].push_back({ value[2], value[3] }); //2:center, 
 	}
 	fclose(fp);
@@ -101,6 +113,7 @@ int TwohopAc::HashJoin(int label1, int label2, int dir){
 			array<int, 2> a = { vertex, dist };
 			arc_map[vertex].push_back(a);
 		}
+		arc_map[vertex].sort(); // sort for pruning
 	}
 
 	/*build support for left*/
@@ -117,13 +130,11 @@ int TwohopAc::HashJoin(int label1, int label2, int dir){
 			for (auto it3 = arc_map[center].begin(); it3 != arc_map[center].end(); it3++){
 				int map_vertex = (*it3)[0];
 				int map_dist = (*it3)[1];
-				if (map_dist + dist <= delta_){ //find the support
-					support.insert(map_vertex);
-				}
-				/*
-				else
-					break; // debug 
-					*/
+				if (map_dist + dist > delta_)
+					break; //this is the second pruning method.
+				//find the support
+				support.insert(map_vertex);
+				
 			}
 		}
 
@@ -137,7 +148,7 @@ int TwohopAc::HashJoin(int label1, int label2, int dir){
 			it1++;
 		}
 
-		/*build support*/
+		/*build support for right*/
 		int i = 0;
 		for (auto it4 = support.begin(); it4 != support.end(); it4++){
 			int s = *it4;
@@ -168,7 +179,7 @@ int TwohopAc::HashJoin(int label1, int label2, int dir){
 	return count;
 }
 
-int TwohopAc::AcJoin(int method){
+int TwohopAc::Sjoin(int method){
 	int count = 0;
 
 	for (auto it = q_->label_pairs()->begin(); it != q_->label_pairs()->end(); it++){
@@ -268,101 +279,4 @@ int TwohopAc::WriteMatches(const char *filename, char* delim){
 
 	fclose(fp);
 	return 0;
-}
-
-int TwohopAc::BucketJoinPre(){
-	NewBucket b;
-	buckets_.insert(buckets_.begin(), g_->max_vertex_num(), b);
-
-	for (unsigned int i = 0; i < labelings_[1].size(); i++){
-		Labeling *labeling = &labelings_[1][i];
-		for (auto it2 = labeling->begin(); it2 != labeling->end(); it2++){
-			int center = it2->first;
-			int weight = it2->second;
-			int vertex = i;
-			buckets_[center].push_back({ vertex, weight });
-		}
-	}
-	typedef pair<int, int> PAIR;
-	auto fun = [](PAIR p1, PAIR p2){
-		return p1.second < p2.second;
-	};
-
-	for (unsigned int i = 0; i < buckets_.size(); i++){
-		buckets_[i].sort(fun);
-	}
-	return 0;
-}
-
-int TwohopAc::BucketJoin(int label1, int label2, int dir ){
-	int count = 0;
-	GroupItems *mygroup[2];
-	mygroup[0] = group_->items(label1);
-	mygroup[1] = group_->items(label2);
-
-	//key: center. value: array[0] center, array[1] dist, ,
-	vector<byte> right(mygroup[OPP(dir)]->size(), 0);
-
-	/*build support for left*/
-	for (auto it1 = mygroup[(dir)]->begin(); it1 != mygroup[(dir)]->end();){
-		int vertex = *it1;
-		auto item = &labelings_[OPP(dir)][vertex];
-		set<int> support; //key: center in the arc_map
-		for (auto it2 = item->begin(); it2 != item->end(); it2++){
-			int center = it2->first;
-			int dist = it2->second;
-			if (dist > delta_)
-				break; //this is pruning method based on the sorted labeling by weight
-
-			for (auto it3 = buckets_[center].begin(); it3 != buckets_[center].end(); it3++){
-				int map_vertex = it3->first;
-				int map_dist = it3->second;
-				if (map_dist + dist <= delta_){ //find the support
-					support.insert(map_vertex);
-				}
-				else
-					break; // debug
-				
-			}
-		}
-
-		if (true == support.empty()){
-			mygroup[(dir)]->erase(it1++);
-			count++;
-			deleted_queue_.push(vertex);
-			continue;
-		}
-		else{
-			it1++;
-		}
-
-		/*build support*/
-		int i = 0;
-		for (auto it4 = support.begin(); it4 != support.end(); it4++){
-			int s = *it4;
-			/*left*/
-			supports_[dir][vertex].push_back(s);
-			counts_[dir][vertex]++;
-			/*right, just opposite*/
-			supports_[OPP(dir)][s].push_back(vertex);
-			counts_[OPP(dir)][s]++;
-			right[i++] = 1;
-		}
-	}
-
-	/*fine the right side one with no support and delete it*/
-	int i = 0;
-	for (auto it1 = mygroup[OPP(dir)]->begin(); it1 != mygroup[OPP(dir)]->end();){
-		int vertex = *it1;
-		if (right[i++] == 0){
-			mygroup[OPP(dir)]->erase(it1++);
-			count++;
-			deleted_queue_.push(vertex);
-		}
-		else{
-			it1++;
-		}
-	}
-
-	return count;
 }
\ No newline at end of file
diff --git a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohopac.h b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohopac.h
index 7d716f8..f613322 100644
--- a/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohopac.h
+++ b/GraphPatternMaching-3/GraphPatternMatch-New-1/code/twohopac.h
@@ -33,20 +33,15 @@ class TwohopAc{
 
 public:
 	TwohopAc(Graph *g, Query *q, Group *gorup);
-	//~TwohopAc();
+	~TwohopAc();
 
 	int ReadLabeling(const char *filename, const char *delim);
 	int SortLabeling();
 
 	int HashJoin(int label1, int label2, int dir = 0);
-	int AcJoin(int method); //ac-4 main function
-	int DeleteQueue(); //ac-4 delete queue
-
-	int BucketJoinPre();
-	int BucketJoin(int lable1, int label2, int dir = 0);
+	int Sjoin(int method); 
 	
 	int WriteMatches(const char *filename, char *delim);
-	
 };
 
 
diff --git a/GraphPatternMaching/GraphPatternMatch-New-1/code/main.cpp b/GraphPatternMaching/GraphPatternMatch-New-1/code/main.cpp
index 31493fc..c966f3e 100644
--- a/GraphPatternMaching/GraphPatternMatch-New-1/code/main.cpp
+++ b/GraphPatternMaching/GraphPatternMatch-New-1/code/main.cpp
@@ -300,15 +300,15 @@ int _tmain(int argc, _TCHAR* argv[]){
 
 	/*init rand seed*/
 	srand((unsigned int)time(NULL));
-#if 0
+#if 1
 
-	//OffLineTwohop();
+	OffLineTwohop();
 
-	//OffLineEmbedding();
+	OffLineEmbedding();
 	
 	OffLineCluster();
 #endif
-#if 1
+#if 0
 	//OnLineTwoHopAC();
 
 	OnLineEmbeddingAC(2); 
diff --git a/GraphPatternMaching/GraphPatternMatch-New-1/code/main.h b/GraphPatternMaching/GraphPatternMatch-New-1/code/main.h
index 48b80a7..41b717b 100644
--- a/GraphPatternMaching/GraphPatternMatch-New-1/code/main.h
+++ b/GraphPatternMaching/GraphPatternMatch-New-1/code/main.h
@@ -9,7 +9,7 @@
 //#define DEBUG_NEIGHBOR_AREA_PRUNING
 
 //#define DEBUG_LARGE_GRAPH
-#define TESTDATA 1
+#define TESTDATA 5
 #if TESTDATA == 0
 #define PATH  "..\\..\\new-test-example\\"
 const int kGraphVertexNum = 16;
@@ -52,12 +52,22 @@ const int kClusterK = 10;
 const int KClusterMaxIteration = 1000;
 #endif
 
+#if TESTDATA == 5
+#define PATH "..\\..\\data-synthetic-graph\\";
+const int kGraphVertexNum = 10000;
+const int kQueryVertexNum = 5;
+const int kDelta = 300;
+const int kClusterK = 100;
+const int KClusterMaxIteration = 1000;
+#endif
+
+
 enum{
 	DIRETED_GRAPH = 1,
 	UNDIRECTED_GRAPH = 2,
 };
 
-#define DUNDIRECTED_GRAPH_DEFINE
+//#define DUNDIRECTED_GRAPH_DEFINE
 #ifdef DUNDIRECTED_GRAPH_DEFINE
 const int gGraphType = UNDIRECTED_GRAPH;
 #else
